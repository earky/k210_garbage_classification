# generated by maixhub, tested on maixpy v0.6.0_2_g9720594
# copy files to TF card and plug into board and power on

import sensor, image, lcd, time
import KPU as kpu
import gc, sys
from machine import PWM,Timer,UART
from fpioa_manager import fm
from Maix import GPIO



input_size = (224, 224)
labels = ['porridge', 'glass', 'PE', 'cotton_swab', 'lamp', 'battery', 'sugar', 'stove', 'charging_head']


#驱动舵机
def Servo(servo,angle):
    servo.duty((angle+90)/180*10+2.5)
#根据不同垃圾来转动不同角度
def Servo_sort(servo,ob_name):
    if ob_name == 'glass' or ob_name == 'charging_head' or ob_name == 'stove':
        Servo(servo,90)
    elif ob_name == 'lamp' or ob_name == 'battery' :
        Servo(servo,45)
    elif ob_name == 'porridge' or ob_name == 'sugar':
        Servo(servo,-45)
    elif ob_name == 'PE' or ob_name == 'cotton_swab':
        Servo(servo,-90)

#清除所有LED灯
def LED_Clear(led_b,led_r,led_g,led_y):
    led_b.value(0)
    led_r.value(0)
    led_g.value(0)
    led_y.value(0)

#点亮对应LED灯
def LED_ON(ob_name,led_b,led_r,led_g,led_y):
    LED_Clear(led_b,led_r,led_g,led_y)
    if ob_name == 'glass' or ob_name == 'charging_head' or ob_name == 'stove':
        led_b.value(1)
    elif ob_name == 'lamp' or ob_name == 'battery' :
        led_r.value(1)
    elif ob_name == 'porridge' or ob_name == 'sugar':
        led_g.value(1)
    elif ob_name == 'PE' or ob_name == 'cotton_swab':
        led_y.value(1)

def lcd_show_except(e):
    import uio
    err_str = uio.StringIO()
    sys.print_exception(e, err_str)
    err_str = err_str.getvalue()
    img = image.Image(size=input_size)
    img.draw_string(0, 10, err_str, scale=1, color=(0xff,0x00,0x00))
    lcd.display(img)

def init_uart():
    fm.register(10, fm.fpioa.UART1_TX, force=True)
    fm.register(11, fm.fpioa.UART1_RX, force=True)

    uart = UART(UART.UART1, 115200, 8, 0, 0, timeout=1000, read_buf_len=256)
    return uart

class Comm:
    def __init__(self, uart):
        self.uart = uart

    def send_classify_result(self, pmax, idx, label):
        msg = "{}:{:.2f}:{}\n".format(idx, pmax, label)
        self.uart.write(msg.encode())

def init_uart():
    fm.register(10, fm.fpioa.UART1_TX, force=True)
    fm.register(11, fm.fpioa.UART1_RX, force=True)

    uart = UART(UART.UART1, 115200, 8, 0, 0, timeout=1000, read_buf_len=256)
    return uart

def main(labels = None, model_addr="/sd/m.kmodel", sensor_window=input_size, lcd_rotation=0, sensor_hmirror=False, sensor_vflip=False):
    sensor.reset()
    sensor.set_pixformat(sensor.RGB565)
    sensor.set_framesize(sensor.QVGA)
    sensor.set_windowing(sensor_window)
    sensor.set_hmirror(sensor_hmirror)
    sensor.set_vflip(sensor_vflip)
    sensor.run(1)

    lcd.init(type=1)
    lcd.rotation(lcd_rotation)
    lcd.clear(lcd.WHITE)
    #注册引脚
    fm.register(0, fm.fpioa.GPIO0, force=True)
    fm.register(1, fm.fpioa.GPIO1, force=True)
    fm.register(2, fm.fpioa.GPIO2, force=True)
    fm.register(3, fm.fpioa.GPIO3, force=True)
    led_b=GPIO(GPIO.GPIO0,GPIO.OUT)
    led_r=GPIO(GPIO.GPIO1,GPIO.OUT)
    led_g=GPIO(GPIO.GPIO2,GPIO.OUT)
    led_y=GPIO(GPIO.GPIO3,GPIO.OUT)
    #初始化定时器，用来配置舵机
    tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)
    #初始化舵机
    servo = PWM(tim, freq=50, duty=0, pin=17)

    if not labels:
        with open('labels.txt','r') as f:
            exec(f.read())
    if not labels:
        print("no labels.txt")
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "no labels.txt", color=(255, 0, 0), scale=2)
        lcd.display(img)
        return 1
    try:
        img = image.Image("startup.jpg")
        lcd.display(img)
    except Exception:
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "loading model...", color=(255, 255, 255), scale=2)
        lcd.display(img)

    uart = init_uart()
    comm = Comm(uart)

    try:
        task = None
        task = kpu.load(model_addr)

        #只有连续识别次数超过10次时，才会开启舵机 开启相应灯光
        object_count = 0
        #需要连续识别的字符串
        object_name = ""
        while(True):
            img = sensor.snapshot()
            t = time.ticks_ms()
            fmap = kpu.forward(task, img)
            t = time.ticks_ms() - t
            plist=fmap[:]
            pmax=max(plist)
            max_index=plist.index(pmax)

            #该次识别到的图像
            this_object = labels[max_index].strip()
            #识别正确 counnt++
            if this_object == object_name:
                object_count+=1
                #连续识别10次 开启灯光和舵机
                if object_count==10:
                    LED_ON(object_name,led_b,led_r,led_g,led_y)
                    Servo_sort(servo,object_name)
            else: #假如不相同 就将count清0 名字更改 灯光关闭 舵机角度清0
                object_count=0
                object_name = this_object
                LED_Clear(led_b,led_r,led_g,led_y)
                Servo(servo,0)



            img.draw_string(0,0, "%.2f : %s" %(pmax, labels[max_index].strip()), scale=2, color=(255, 0, 0))
            img.draw_string(0, 200, "t:%dms" %(t), scale=2, color=(255, 0, 0))
            comm.send_classify_result(pmax, max_index, labels[max_index].strip())
            lcd.display(img)
    except Exception as e:
        raise e
    finally:
        if not task is None:
            kpu.deinit(task)




if __name__ == "__main__":
    try:
        # main(labels=labels, model_addr=0x300000)
        main(labels=labels, model_addr="/sd/model-145849.kmodel")
    except Exception as e:
        sys.print_exception(e)
        lcd_show_except(e)
    finally:
        gc.collect()
